/*⠀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⣿⢫⣶⢾⣰⣿⣑⣶⣕⡫⢙⣭⣖⣷⣶⣹⣿⣻⣟⠉⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⣿⣮⡟⣼⣶⣶⠶⠶⠶⢶⣶⢶⠶⠶⠶⢶⣶⣶⡶⢰⢿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⣿⡼⠱⣫⣶⣾⠟⠿⣿⠨⣆⣿⢰⣿⠿⣿⢶⣬⠃⣷⣾⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⣿⢿⣾⢿⣷⣌⣀⣈⣿⠘⣧⢸⢸⡿⡟⢁⣋⡩⣷⣬⣾⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⣿⠹⣑⡲⣶⣦⡻⠿⣿⢠⣍⢴⢸⣿⣰⣿⡿⢃⣜⢗⣸⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⣿⢸⢿⡿⠋⠙⣿⠹⣿⢸⠏⠾⢸⣯⢣⣾⣟⣻⣭⡛⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⣤⣤⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⣿⣞⢾⣧⣻⣾⣋⣾⣾⠀⠸⢓⢸⡟⣆⢿⢼⣗⠉⡽⣸⡇⠀⠀⣠⡦⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠂⠁⠀⠉⠙⢿⣷⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡀⠀⠀
 *⠀⣿⢛⣥⣬⣛⡿⣦⢫⣿⢸⣇⣿⢸⡿⣳⣥⣜⣿⢿⡾⢿⡇⠀⠀⢈⡀⠀⠀⢀⡀⠀⢀⣀⠀⠀⠀⣀⡀⠀⠀⠀⢀⡀⠀⠀⣴⠃⠀⠀⠀⠀⠀⠀⢻⣿⠀⠀⣀⡀⠀⢀⣀⠀⠀⢀⣾⣇⣀⡀
 *⠀⣿⣿⢋⣽⣶⣯⡈⢼⣿⠸⣦⢸⢸⡟⠿⢍⣿⣝⠸⣸⢿⡇⠀⠐⢿⡇⠀⠐⢿⡧⠐⠙⢻⣷⠀⠈⢻⣿⠀⠀⠀⢻⣷⠀⢸⣿⠀⠀⠀⠀⠀⠀⠀⠈⣿⠂⠘⣿⡧⠊⠙⢿⣷⠀⠉⣿⡏⠉⠀
 *⠀⣿⡗⣼⣟⣉⢻⡹⢸⣿⢸⡌⣸⠘⡿⠿⣿⣟⣻⡇⣱⣿⡇⠀⠀⢸⡇⠀⠀⢸⡇⠀⠀⢸⣿⠀⠀⢸⣿⠀⠀⠀⢸⣿⠀⢸⣿⡀⠀⠀⠀⠀⠀⠀⢀⡿⠀⠀⣿⡇⠀⠀⠈⣿⠀⠀⣿⡇⠀⠀
 *⠀⣿⣷⢩⣿⣵⡿⣣⡾⣣⣟⣁⣙⣧⡻⢇⡽⢟⣉⠪⢭⣿⡇⠀⠀⢸⡇⠀⠀⢸⡇⠀⠀⢸⣿⠀⠀⢸⣿⡀⠀⠀⣸⡇⠀⠈⢿⣷⣄⠀⠀⠀⠀⢀⡼⠁⠀⠀⣿⡇⠀⠀⢀⠟⠀⠀⣿⡇⠀⠀
 *⠀⠿⠶⠾⠿⠶⠿⠿⠶⠶⠶⠶⠶⠶⠶⠾⠿⠿⠿⠿⠾⠿⠇⠀⠀⠸⠿⠂⠀⠸⠿⠂⠀⠘⠿⠓⠀⠈⠻⡿⠒⠁⢸⣷⠀⠀⠀⠙⠻⠿⠶⠶⠖⠉⠀⠀⠀⠀⣿⡿⠿⠖⠀⠀⠀⠀⠻⠿⠖⠀
 *⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⡎⠀⠀⠀⢸⠏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⠻⠿⠶⠂⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠛⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *  TinyOpt
 *  Copyright (c) 2025 leozamboni
 *
 *  this program is free software: you can redistribute it and/or modify
 *  it under the terms of the gnu general public license as published by
 *  the free software foundation, either version 3 of the license, or
 *  (at your option) any later version.
 *
 *  this program is distributed in the hope that it will be useful,
 *  but without any warranty; without even the implied warranty of
 *  merchantability or fitness for a particular purpose.  see the
 *  gnu general public license for more details.
 *
 *  you should have received a copy of the gnu general public license
 *  along with this program.  if not, see <http://www.gnu.org/licenses/>.
 */
#include "tinyopt_dead_store.h"
#include "tinyopt_cfg.h"

static int assignments_same_var (TinyOptAssignmentNode_t *a,
                                 TinyOptAssignmentNode_t *b);
static int ast_uses_var (TinyOptASTNode_t *node, const char *name);

void
tinyopt_dead_store (TinyOptASTNode_t *ast, TinyOptStab_t *table)
{
  (void)table; /* atualmente não utilizado, reservado para futuras extensões */

  if (!ast)
    return;

  TinyOptCFG_t *cfg = tinyopt_cfg_build (ast);
  if (!cfg || !cfg->nodes)
    {
      if (cfg)
        tinyopt_cfg_free (cfg);
      return;
    }

  for (TinyOptCFGNode_t *n = cfg->nodes; n; n = n->next_in_cfg)
    {
      TinyOptASTNode_t *node = n->ast;
      if (!node || node->is_dead_code || node->type != NODE_ASSIGNMENT)
        continue;

      TinyOptAssignmentNode_t *assign = (TinyOptAssignmentNode_t *)node;

      /* Caso 1: auto-atribuição trivial x = x; */
      if (assign->op == OP_ASSIGN && assign->value
          && assign->value->type == NODE_IDENTIFIER)
        {
          TinyOptIdentifierNode_t *id
              = (TinyOptIdentifierNode_t *)assign->value;
          if (id->name && assign->variable
              && strcmp (id->name, assign->variable) == 0)
            {
              node->is_dead_code = 1;
              continue;
            }
        }

      /* Caso 2: atribuição sobrescrita posteriormente no mesmo bloco
       * linear de controle, sem uso intermediário da variável:
       *
       *   a = 1;
       *   ...   // nenhum uso de 'a'
       *   a = 2;
       *
       * Percorremos a cadeia de succ_true enquanto não houver bifurcação
       * (succ_false == NULL). Se encontrarmos uma atribuição à mesma
       * variável antes de qualquer uso, a primeira é dead store.
       */
      if (!assign->variable)
        continue;

      const char *var_name = assign->variable;
      TinyOptCFGNode_t *cur = n->succ_true;

      while (cur && !cur->succ_false && cur->ast && !cur->ast->is_dead_code)
        {
          TinyOptASTNode_t *cnode = cur->ast;

          /* Se a variável for usada em qualquer nó intermediário, a store
           * inicial não é morta. */
          if (ast_uses_var (cnode, var_name))
            break;

          if (cnode->type == NODE_ASSIGNMENT)
            {
              TinyOptAssignmentNode_t *next_assign
                  = (TinyOptAssignmentNode_t *)cnode;

              if (assignments_same_var (assign, next_assign))
                {
                  /* a = ...; a = ...;  -> primeira store é morta */
                  if (next_assign->op == OP_ASSIGN)
                    {
                      node->is_dead_code = 1;
                    }

                  /* a++ seguido de a-- (ou vice-versa) e nenhuma outra
                   * operação entre eles: descarta a primeira. */
                  else if ((assign->op == OP_INC && next_assign->op == OP_DEC)
                           || (assign->op == OP_DEC
                               && next_assign->op == OP_INC))
                    {
                      cnode->is_dead_code = 1;
                      node->is_dead_code = 1;
                    }

                  break;
                }
            }

          cur = cur->succ_true;
        }
    }

  tinyopt_cfg_free (cfg);

  // /* Passagem adicional baseada na tabela de símbolos para cobrir
  //  * todos os casos do dead store original (incluindo padrões mais
  //  * agressivos de sobrescrita e cancelamento aritmético). */
  // if (!table)
  //   return;

  // for (size_t i = 0; i < table->size; i++)
  //   {
  //     SymbolBucket *bucket = table->buckets[i];

  //     while (bucket)
  //       {
  //         Symbol *entry = bucket->symbol;

  //         if (!entry || !entry->node || entry->node->is_dead_code
  //             || entry->node->type != NODE_ASSIGNMENT)
  //           {
  //             bucket = bucket->next;
  //             continue;
  //           }

  //         TinyOptAssignmentNode_t *assign
  //             = (TinyOptAssignmentNode_t *)entry->node;

  //         /* CASO 1 (já coberto acima, mas mantido por compatibilidade):
  //          * autoatribuição n = n; */
  //         if (assign->op == OP_ASSIGN && assign->value
  //             && assign->value->type == NODE_IDENTIFIER)
  //           {
  //             TinyOptIdentifierNode_t *id
  //                 = (TinyOptIdentifierNode_t *)assign->value;

  //             if (id->name && assign->variable
  //                 && strcmp (id->name, assign->variable) == 0)
  //               {
  //                 entry->node->is_dead_code = 1;
  //                 bucket = bucket->next;
  //                 continue;
  //               }
  //           }

  //         /* CASO 2–4: olhar o próximo símbolo na tabela (heurística
  //          * original baseada em ordem de inserção). */
  //         SymbolBucket *next_bucket = bucket->next;
  //         while (next_bucket)
  //           {
  //             Symbol *next_sym = next_bucket->symbol;

  //             if (!next_sym || !next_sym->node || next_sym->node->is_dead_code)
  //               {
  //                 next_bucket = next_bucket->next;
  //                 continue;
  //               }

  //             if (next_sym->node->type != NODE_ASSIGNMENT)
  //               {
  //                 next_bucket = next_bucket->next;
  //                 continue;
  //               }

  //             TinyOptAssignmentNode_t *next_assign
  //                 = (TinyOptAssignmentNode_t *)next_sym->node;

  //             if (!assign->variable || !next_assign->variable
  //                 || strcmp (assign->variable, next_assign->variable) != 0)
  //               {
  //                 next_bucket = next_bucket->next;
  //                 continue;
  //               }

  //             Operator a = assign->op;
  //             Operator b = next_assign->op;

  //             /* CASO 2: sobrescrita simples (a = 1; a = 2;) */
  //             if (b == OP_ASSIGN)
  //               {
  //                 entry->node->is_dead_code = 1;
  //                 break;
  //               }

  //             /* CASO 3: ++ / -- */
  //             if ((a == OP_INC && b == OP_DEC) || (a == OP_DEC && b == OP_INC))
  //               {
  //                 entry->node->is_dead_code = 1;
  //                 break;
  //               }

  //             /* CASO 4: operações reversas aritméticas (ex: +=X / -=X)
  //              * usando os valores constantes inferidos na tabela. */
  //             int dead = 0;

  //             if (entry->value && next_sym->value
  //                 && entry->value->type == VALUE_TYPE_INT
  //                 && next_sym->value->type == VALUE_TYPE_INT)
  //               {
  //                 int v1 = entry->value->number;
  //                 int v2 = next_sym->value->number;

  //                 if (((a == OP_ADD_ASSIGN && b == OP_SUB_ASSIGN)
  //                      || (a == OP_SUB_ASSIGN && b == OP_ADD_ASSIGN))
  //                     && v1 == v2)
  //                   dead = 1;

  //                 else if (((a == OP_MUL_ASSIGN && b == OP_DIV_ASSIGN)
  //                           || (a == OP_DIV_ASSIGN && b == OP_MUL_ASSIGN))
  //                          && v1 == v2 && v1 != 0 && v1 != 1)
  //                   dead = 1;

  //                 else if (((a == OP_MOD_ASSIGN && b == OP_MUL_ASSIGN)
  //                           || (a == OP_MUL_ASSIGN && b == OP_MOD_ASSIGN))
  //                          && v1 == v2)
  //                   dead = 1;
  //               }

  //             if (dead)
  //               {
  //                 entry->node->is_dead_code = 1;
  //                 next_sym->node->is_dead_code = 1;
  //                 break;
  //               }

  //             break;
  //           }

  //         bucket = bucket->next;
  //       }
  //   }
}

static int
assignments_same_var (TinyOptAssignmentNode_t *a, TinyOptAssignmentNode_t *b)
{
  if (!a || !b)
    return 0;
  if (!a->variable || !b->variable)
    return 0;
  return strcmp (a->variable, b->variable) == 0;
}

static int
ast_uses_var (TinyOptASTNode_t *node, const char *name)
{
  if (!node || !name)
    return 0;

  switch (node->type)
    {
    case NODE_IDENTIFIER:
      {
        TinyOptIdentifierNode_t *id = (TinyOptIdentifierNode_t *)node;
        return (id->name && strcmp (id->name, name) == 0);
      }
    case NODE_DECLARATION:
      {
        TinyOptDeclarationNode_t *d = (TinyOptDeclarationNode_t *)node;
        if (d->initial_value && ast_uses_var (d->initial_value, name))
          return 1;
        break;
      }
    case NODE_ASSIGNMENT:
      {
        TinyOptAssignmentNode_t *a = (TinyOptAssignmentNode_t *)node;
        if (a->value && ast_uses_var (a->value, name))
          return 1;
        break;
      }
    case NODE_RETURN:
      {
        TinyOptReturnNode_t *r = (TinyOptReturnNode_t *)node;
        if (r->value && ast_uses_var (r->value, name))
          return 1;
        break;
      }
    case NODE_BINARY_OP:
      {
        TinyOptBinaryOpNode_t *b = (TinyOptBinaryOpNode_t *)node;
        return ast_uses_var (b->left, name)
               || ast_uses_var (b->right, name);
      }
    case NODE_CONDITION:
      {
        TinyOptConditionNode_t *c = (TinyOptConditionNode_t *)node;
        return ast_uses_var (c->left, name)
               || ast_uses_var (c->right, name);
      }
    case NODE_UNARY_OP:
      {
        TinyOptUnaryOpNode_t *u = (TinyOptUnaryOpNode_t *)node;
        return ast_uses_var (u->operand, name);
      }
    case NODE_FUNCTION_CALL:
      {
        TinyOptFunctionCallNode_t *call = (TinyOptFunctionCallNode_t *)node;
        TinyOptASTNode_t *args = call->arguments;
        while (args)
          {
            if (ast_uses_var (args, name))
              return 1;
            args = args->next;
          }
        break;
      }
    case NODE_IF_STATEMENT:
      {
        TinyOptIfNode_t *i = (TinyOptIfNode_t *)node;
        if (ast_uses_var (i->condition, name))
          return 1;
        if (ast_uses_var (i->then_statement, name))
          return 1;
        if (ast_uses_var (i->else_statement, name))
          return 1;
        break;
      }
    case NODE_WHILE_STATEMENT:
      {
        TinyOptWhileNode_t *w = (TinyOptWhileNode_t *)node;
        if (ast_uses_var (w->condition, name))
          return 1;
        if (ast_uses_var (w->body, name))
          return 1;
        break;
      }
    case NODE_FOR_STATEMENT:
      {
        TinyOptForNode_t *f = (TinyOptForNode_t *)node;
        if (ast_uses_var (f->init, name))
          return 1;
        if (ast_uses_var (f->condition, name))
          return 1;
        if (ast_uses_var (f->increment, name))
          return 1;
        if (ast_uses_var (f->body, name))
          return 1;
        break;
      }
    case NODE_COMPOUND_STATEMENT:
      {
        TinyOptCompoundNode_t *c = (TinyOptCompoundNode_t *)node;
        TinyOptASTNode_t *stmt = c->statements;
        while (stmt)
          {
            if (ast_uses_var (stmt, name))
              return 1;
            stmt = stmt->next;
          }
        break;
      }
    default:
      break;
    }

  return 0;
}