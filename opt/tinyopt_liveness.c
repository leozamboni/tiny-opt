/*⠀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⣿⢫⣶⢾⣰⣿⣑⣶⣕⡫⢙⣭⣖⣷⣶⣹⣿⣻⣟⠉⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⣿⣮⡟⣼⣶⣶⠶⠶⠶⢶⣶⢶⠶⠶⠶⢶⣶⣶⡶⢰⢿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⣿⡼⠱⣫⣶⣾⠟⠿⣿⠨⣆⣿⢰⣿⠿⣿⢶⣬⠃⣷⣾⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⣿⢿⣾⢿⣷⣌⣀⣈⣿⠘⣧⢸⢸⡿⡟⢁⣋⡩⣷⣬⣾⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⣿⠹⣑⡲⣶⣦⡻⠿⣿⢠⣍⢴⢸⣿⣰⣿⡿⢃⣜⢗⣸⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⣿⢸⢿⡿⠋⠙⣿⠹⣿⢸⠏⠾⢸⣯⢣⣾⣟⣻⣭⡛⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⣤⣤⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⣿⣞⢾⣧⣻⣾⣋⣾⣾⠀⠸⢓⢸⡟⣆⢿⢼⣗⠉⡽⣸⡇⠀⠀⣠⡦⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠂⠁⠀⠉⠙⢿⣷⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡀⠀⠀
 *⠀⣿⢛⣥⣬⣛⡿⣦⢫⣿⢸⣇⣿⢸⡿⣳⣥⣜⣿⢿⡾⢿⡇⠀⠀⢈⡀⠀⠀⢀⡀⠀⢀⣀⠀⠀⠀⣀⡀⠀⠀⠀⢀⡀⠀⠀⣴⠃⠀⠀⠀⠀⠀⠀⢻⣿⠀⠀⣀⡀⠀⢀⣀⠀⠀⢀⣾⣇⣀⡀
 *⠀⣿⣿⢋⣽⣶⣯⡈⢼⣿⠸⣦⢸⢸⡟⠿⢍⣿⣝⠸⣸⢿⡇⠀⠐⢿⡇⠀⠐⢿⡧⠐⠙⢻⣷⠀⠈⢻⣿⠀⠀⠀⢻⣷⠀⢸⣿⠀⠀⠀⠀⠀⠀⠀⠈⣿⠂⠘⣿⡧⠊⠙⢿⣷⠀⠉⣿⡏⠉⠀
 *⠀⣿⡗⣼⣟⣉⢻⡹⢸⣿⢸⡌⣸⠘⡿⠿⣿⣟⣻⡇⣱⣿⡇⠀⠀⢸⡇⠀⠀⢸⡇⠀⠀⢸⣿⠀⠀⢸⣿⠀⠀⠀⢸⣿⠀⢸⣿⡀⠀⠀⠀⠀⠀⠀⢀⡿⠀⠀⣿⡇⠀⠀⠈⣿⠀⠀⣿⡇⠀⠀
 *⠀⣿⣷⢩⣿⣵⡿⣣⡾⣣⣟⣁⣙⣧⡻⢇⡽⢟⣉⠪⢭⣿⡇⠀⠀⢸⡇⠀⠀⢸⡇⠀⠀⢸⣿⠀⠀⢸⣿⡀⠀⠀⣸⡇⠀⠈⢿⣷⣄⠀⠀⠀⠀⢀⡼⠁⠀⠀⣿⡇⠀⠀⢀⠟⠀⠀⣿⡇⠀⠀
 *⠀⠿⠶⠾⠿⠶⠿⠿⠶⠶⠶⠶⠶⠶⠶⠾⠿⠿⠿⠿⠾⠿⠇⠀⠀⠸⠿⠂⠀⠸⠿⠂⠀⠘⠿⠓⠀⠈⠻⡿⠒⠁⢸⣷⠀⠀⠀⠙⠻⠿⠶⠶⠖⠉⠀⠀⠀⠀⣿⡿⠿⠖⠀⠀⠀⠀⠻⠿⠖⠀
 *⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⡎⠀⠀⠀⢸⠏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⠻⠿⠶⠂⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠛⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *  TinyOpt
 *  Copyright (c) 2025 leozamboni
 *
 *  this program is free software: you can redistribute it and/or modify
 *  it under the terms of the gnu general public license as published by
 *  the free software foundation, either version 3 of the license, or
 *  (at your option) any later version.
 *
 *  this program is distributed in the hope that it will be useful,
 *  but without any warranty; without even the implied warranty of
 *  merchantability or fitness for a particular purpose.  see the
 *  gnu general public license for more details.
 *
 *  you should have received a copy of the gnu general public license
 *  along with this program.  if not, see <http://www.gnu.org/licenses/>.
 */
#include "tinyopt_liveness.h"
#include "tinyopt_cfg.h"
#include "tinyopt_core.h"
#include "tinyopt_stab.h"
#include <stdlib.h>
#include <string.h>

typedef struct
{
  uint64_t *data;
  size_t size;
  size_t capacity;
} VarSet;

static void varset_init (VarSet *s);
static void varset_free (VarSet *s);
static int varset_contains (VarSet *s, uint64_t v);
static int varset_add (VarSet *s, uint64_t v);
static int varset_union_into (VarSet *dst, VarSet *src);
static void varset_minus (VarSet *dst, VarSet *remove);

static void collect_uses_expr (TinyOptASTNode_t *node, VarSet *use);
static void compute_use_def_for_node (TinyOptCFGNode_t *n, VarSet *use,
                                      VarSet *def);
static int run_liveness_analysis (TinyOptASTNode_t *ast);
static void collect_global_vars_used_in_function (TinyOptASTNode_t *func_body,
                                                  VarSet *global_uses);

void
tinyopt_liveness (TinyOptASTNode_t *ast)
{
  if (!ast)
    return;

  if (ast->type == NODE_PROGRAM)
    {
      TinyOptProgramNode_t *prog = (TinyOptProgramNode_t *)ast;

      /* Primeiro, coleta todas as variáveis globais usadas em todas as
       * funções. */
      VarSet global_uses;
      varset_init (&global_uses);

      for (TinyOptASTNode_t *stmt = prog->statements; stmt; stmt = stmt->next)
        {
          if (stmt->type == NODE_FUNCTION_DEF)
            {
              TinyOptFunctionDefNode_t *func
                  = (TinyOptFunctionDefNode_t *)stmt;
              if (func->body)
                {
                  collect_global_vars_used_in_function (func->body,
                                                        &global_uses);
                }
            }
        }

      /* Agora, itera sobre cada função para fazer liveness. */
      for (TinyOptASTNode_t *stmt = prog->statements; stmt; stmt = stmt->next)
        {
          if (stmt->type == NODE_FUNCTION_DEF)
            {
              TinyOptFunctionDefNode_t *func
                  = (TinyOptFunctionDefNode_t *)stmt;
              if (func->body)
                {
                  /* Executa liveness apenas no corpo da função. */
                  int dead_count;
                  int max_rounds = 100;
                  int round = 0;

                  do
                    {
                      dead_count = run_liveness_analysis (func->body);
                      if (dead_count > 0)
                        {
                          tinyopt_remove_dead_code (func->body);
                        }
                      round++;
                    }
                  while (dead_count > 0 && round < max_rounds);
                }
            }
          else
            {
              /* Analisa declarações globais: marca como mortas se não são
               * usadas. */
              TinyOptDeclarationNode_t *decl
                  = (TinyOptDeclarationNode_t *)stmt;
              if (decl->name)
                {
                  uint64_t h = stab_hash_string (decl->name);
                  if (!varset_contains (&global_uses, h))
                    {
                      stmt->is_dead_code = 1;
                    }
                }
            }
        }

      varset_free (&global_uses);
      return;
    }
}

/* Executa uma única passada da análise de liveness e retorna o número de
 * atribuições mortas encontradas. */
static int
run_liveness_analysis (TinyOptASTNode_t *ast)
{
  if (!ast)
    return 0;

  TinyOptCFG_t *cfg = tinyopt_cfg_build (ast);
  if (!cfg || !cfg->nodes)
    {
      if (cfg)
        tinyopt_cfg_free (cfg);
      return 0;
    }

  /* Conta nós e determina o maior id para dimensionar vetores por id-1. */
  size_t count = 0;
  int max_id = 0;
  for (TinyOptCFGNode_t *n = cfg->nodes; n; n = n->next_in_cfg)
    {
      count++;
      if (n->id > max_id)
        max_id = n->id;
    }

  if (max_id <= 0)
    {
      tinyopt_cfg_free (cfg);
      return 0;
    }

  size_t n_nodes = (size_t)max_id;

  VarSet *use = (VarSet *)calloc (n_nodes, sizeof (VarSet));
  VarSet *def = (VarSet *)calloc (n_nodes, sizeof (VarSet));
  VarSet *in = (VarSet *)calloc (n_nodes, sizeof (VarSet));
  VarSet *out = (VarSet *)calloc (n_nodes, sizeof (VarSet));

  if (!use || !def || !in || !out)
    {
      free (use);
      free (def);
      free (in);
      free (out);
      tinyopt_cfg_free (cfg);
      return 0;
    }

  for (size_t i = 0; i < n_nodes; i++)
    {
      varset_init (&use[i]);
      varset_init (&def[i]);
      varset_init (&in[i]);
      varset_init (&out[i]);
    }

  /* Computa USE/DEF de cada nó (ignorando nós já marcados como mortos). */
  for (TinyOptCFGNode_t *n = cfg->nodes; n; n = n->next_in_cfg)
    {
      if (n->id <= 0)
        continue;
      /* Ignora nós já marcados como código morto. */
      if (n->ast && n->ast->is_dead_code)
        continue;
      size_t idx = (size_t)(n->id - 1);
      compute_use_def_for_node (n, &use[idx], &def[idx]);
    }

  /* Iteração de ponto fixo: IN/OUT. */
  int changed;
  int iter = 0;
  const int max_iter = 1000;
  do
    {
      changed = 0;
      iter++;

      for (TinyOptCFGNode_t *n = cfg->nodes; n; n = n->next_in_cfg)
        {
          if (n->id <= 0)
            continue;
          /* Ignora nós já marcados como código morto. */
          if (n->ast && n->ast->is_dead_code)
            continue;
          size_t idx = (size_t)(n->id - 1);

          /* OUT[n] = união dos IN dos sucessores */
          VarSet new_out;
          varset_init (&new_out);

          if (n->succ_true && n->succ_true->id > 0)
            {
              size_t tidx = (size_t)(n->succ_true->id - 1);
              varset_union_into (&new_out, &in[tidx]);
            }
          if (n->succ_false && n->succ_false->id > 0)
            {
              size_t fidx = (size_t)(n->succ_false->id - 1);
              varset_union_into (&new_out, &in[fidx]);
            }

          /* Verifica se OUT mudou (tamanho ou conteúdo). */
          int out_changed = 0;
          if (new_out.size != out[idx].size)
            {
              out_changed = 1;
            }
          else
            {
              for (size_t k = 0; k < new_out.size; k++)
                {
                  if (!varset_contains (&out[idx], new_out.data[k]))
                    {
                      out_changed = 1;
                      break;
                    }
                }
            }

          if (out_changed)
            {
              varset_free (&out[idx]);
              out[idx] = new_out;
            }
          else
            {
              varset_free (&new_out);
            }

          /* IN[n] = USE[n] ∪ (OUT[n] – DEF[n]) */
          VarSet new_in;
          varset_init (&new_in);

          varset_union_into (&new_in, &out[idx]);
          varset_minus (&new_in, &def[idx]);
          varset_union_into (&new_in, &use[idx]);

          int in_changed = 0;
          if (new_in.size != in[idx].size)
            {
              in_changed = 1;
            }
          else
            {
              for (size_t k = 0; k < new_in.size; k++)
                {
                  if (!varset_contains (&in[idx], new_in.data[k]))
                    {
                      in_changed = 1;
                      break;
                    }
                }
            }

          if (in_changed)
            {
              varset_free (&in[idx]);
              in[idx] = new_in;
            }
          else
            {
              varset_free (&new_in);
            }

          if (out_changed || in_changed)
            changed = 1;
        }
    }
  while (changed && iter < max_iter);

  /* Marca declarações/atribuições cujo valor nunca está vivo após o nó. */
  /* Primeiro, coletamos todas as variáveis que são de fato usadas em
   * expressões (USE sets) para poder remover declarações completamente
   * não utilizadas. */
  VarSet used_vars;
  varset_init (&used_vars);
  for (TinyOptCFGNode_t *n = cfg->nodes; n; n = n->next_in_cfg)
    {
      if (!n->ast || n->id <= 0)
        continue;
      /* Ignora nós já marcados como código morto. */
      if (n->ast->is_dead_code)
        continue;
      size_t idx = (size_t)(n->id - 1);
      varset_union_into (&used_vars, &use[idx]);
    }

  int dead_count = 0;
  for (TinyOptCFGNode_t *n = cfg->nodes; n; n = n->next_in_cfg)
    {
      if (!n->ast || n->id <= 0)
        continue;
      /* Ignora nós já marcados como código morto. */
      if (n->ast->is_dead_code)
        continue;

      TinyOptASTNode_t *node = n->ast;

      /* Declarações completamente não utilizadas (variável nunca aparece em
       * nenhum USE) podem ser removidas com segurança. */
      if (node->type == NODE_DECLARATION)
        {
          TinyOptDeclarationNode_t *d = (TinyOptDeclarationNode_t *)node;
          if (d->name)
            {
              uint64_t h = stab_hash_string (d->name);
              if (!varset_contains (&used_vars, h))
                {
                  node->is_dead_code = 1;
                  dead_count++;
                  continue;
                }
            }
        }

      /* Por segurança, só removemos atribuições mortas.
       * Declarações são mantidas para preservar a correção do código gerado,
       * mesmo que a definição inicial nunca seja utilizada.
       */
      if (node->type != NODE_ASSIGNMENT)
        continue;

      uint64_t var_hash = 0;
      TinyOptAssignmentNode_t *a = (TinyOptAssignmentNode_t *)node;
      if (a->variable)
        var_hash = stab_hash_string (a->variable);

      if (!var_hash)
        continue;

      size_t idx = (size_t)(n->id - 1);
      if (!varset_contains (&out[idx], var_hash))
        {
          node->is_dead_code = 1;
          dead_count++;
        }
    }

  for (size_t i = 0; i < n_nodes; i++)
    {
      varset_free (&use[i]);
      varset_free (&def[i]);
      varset_free (&in[i]);
      varset_free (&out[i]);
    }

  varset_free (&used_vars);

  for (size_t i = 0; i < n_nodes; i++)
    {
      varset_free (&use[i]);
      varset_free (&def[i]);
      varset_free (&in[i]);
      varset_free (&out[i]);
    }

  free (use);
  free (def);
  free (in);
  free (out);

  tinyopt_cfg_free (cfg);

  return dead_count;
}

static void
varset_init (VarSet *s)
{
  s->data = NULL;
  s->size = 0;
  s->capacity = 0;
}

static void
varset_free (VarSet *s)
{
  free (s->data);
  s->data = NULL;
  s->size = 0;
  s->capacity = 0;
}

static int
varset_contains (VarSet *s, uint64_t v)
{
  for (size_t i = 0; i < s->size; i++)
    {
      if (s->data[i] == v)
        return 1;
    }
  return 0;
}

static int
varset_add (VarSet *s, uint64_t v)
{
  if (varset_contains (s, v))
    return 0;

  if (s->size == s->capacity)
    {
      size_t new_cap = s->capacity ? s->capacity * 2 : 4;
      uint64_t *new_data
          = (uint64_t *)realloc (s->data, new_cap * sizeof (uint64_t));
      if (!new_data)
        return -1;
      s->data = new_data;
      s->capacity = new_cap;
    }
  s->data[s->size++] = v;
  return 1;
}

static int
varset_union_into (VarSet *dst, VarSet *src)
{
  int changed = 0;
  for (size_t i = 0; i < src->size; i++)
    {
      if (varset_add (dst, src->data[i]) == 1)
        changed = 1;
    }
  return changed;
}

static void
varset_minus (VarSet *dst, VarSet *remove)
{
  size_t w = 0;
  for (size_t i = 0; i < dst->size; i++)
    {
      uint64_t v = dst->data[i];
      if (!varset_contains (remove, v))
        {
          dst->data[w++] = v;
        }
    }
  dst->size = w;
}

static void
collect_uses_expr (TinyOptASTNode_t *node, VarSet *use)
{
  if (!node)
    return;

  switch (node->type)
    {
    case NODE_IDENTIFIER:
      {
        TinyOptIdentifierNode_t *id = (TinyOptIdentifierNode_t *)node;
        if (id->name)
          {
            uint64_t h = stab_hash_string (id->name);
            varset_add (use, h);
          }
        break;
      }
    case NODE_NUMBER:
    case NODE_CHAR_LITERAL:
    case NODE_STRING_LITERAL:
      /* não usam variáveis */
      break;
    case NODE_BINARY_OP:
      {
        TinyOptBinaryOpNode_t *b = (TinyOptBinaryOpNode_t *)node;
        collect_uses_expr (b->left, use);
        collect_uses_expr (b->right, use);
        break;
      }
    case NODE_CONDITION:
      {
        TinyOptConditionNode_t *c = (TinyOptConditionNode_t *)node;
        collect_uses_expr (c->left, use);
        collect_uses_expr (c->right, use);
        break;
      }
    case NODE_UNARY_OP:
      {
        TinyOptUnaryOpNode_t *u = (TinyOptUnaryOpNode_t *)node;
        collect_uses_expr (u->operand, use);
        break;
      }
    case NODE_FUNCTION_CALL:
      {
        TinyOptFunctionCallNode_t *call = (TinyOptFunctionCallNode_t *)node;
        TinyOptASTNode_t *args = call->arguments;
        while (args)
          {
            collect_uses_expr (args, use);
            args = args->next;
          }
        break;
      }
    default:
      /* fallback genérico: percorre next como lista de expressões */
      collect_uses_expr (node->next, use);
      break;
    }
}

static void
compute_use_def_for_node (TinyOptCFGNode_t *n, VarSet *use, VarSet *def)
{
  if (!n || !n->ast)
    return;

  TinyOptASTNode_t *node = n->ast;

  switch (node->type)
    {
    case NODE_DECLARATION:
      {
        TinyOptDeclarationNode_t *d = (TinyOptDeclarationNode_t *)node;
        if (d->name)
          {
            uint64_t h = stab_hash_string (d->name);
            varset_add (def, h);
          }
        if (d->initial_value)
          collect_uses_expr (d->initial_value, use);
        break;
      }
    case NODE_ASSIGNMENT:
      {
        TinyOptAssignmentNode_t *a = (TinyOptAssignmentNode_t *)node;
        if (a->variable)
          {
            uint64_t h = stab_hash_string (a->variable);
            varset_add (def, h);
            if (a->op != OP_ASSIGN)
              {
                varset_add (use, h);
              }
          }

        if (a->value)
          collect_uses_expr (a->value, use);
        break;
      }
    case NODE_RETURN:
      {
        TinyOptReturnNode_t *r = (TinyOptReturnNode_t *)node;
        if (r->value)
          collect_uses_expr (r->value, use);
        break;
      }
    case NODE_IF_STATEMENT:
      {
        TinyOptIfNode_t *i = (TinyOptIfNode_t *)node;
        if (i->condition)
          collect_uses_expr (i->condition, use);
        break;
      }
    case NODE_WHILE_STATEMENT:
      {
        TinyOptWhileNode_t *w = (TinyOptWhileNode_t *)node;
        if (w->condition)
          collect_uses_expr (w->condition, use);
        break;
      }
    case NODE_FOR_STATEMENT:
      {
        TinyOptForNode_t *f = (TinyOptForNode_t *)node;
        if (f->condition)
          collect_uses_expr (f->condition, use);
        break;
      }
    case NODE_FUNCTION_CALL:
      {
        TinyOptFunctionCallNode_t *call = (TinyOptFunctionCallNode_t *)node;
        TinyOptASTNode_t *args = call->arguments;
        while (args)
          {
            collect_uses_expr (args, use);
            args = args->next;
          }
        break;
      }
    default:
      /* outros tipos: podem conter expressões; tenta tratá-los como expressão
       */
      collect_uses_expr (node, use);
      break;
    }
}

/* Coleta todas as variáveis (identificadores) usadas em uma função.
 * Esta função é usada para determinar quais variáveis globais são usadas. */
static void
collect_global_vars_used_in_function (TinyOptASTNode_t *func_body,
                                      VarSet *global_uses)
{
  if (!func_body)
    return;

  switch (func_body->type)
    {
    case NODE_IDENTIFIER:
      {
        TinyOptIdentifierNode_t *id = (TinyOptIdentifierNode_t *)func_body;
        if (id->name)
          {
            uint64_t h = stab_hash_string (id->name);
            varset_add (global_uses, h);
          }
        break;
      }
    case NODE_DECLARATION:
      {
        /* Declaração local: coleta variáveis usadas no valor inicial,
         * mas não adiciona a própria variável declarada (é local). */
        TinyOptDeclarationNode_t *decl = (TinyOptDeclarationNode_t *)func_body;
        if (decl->initial_value)
          {
            collect_global_vars_used_in_function (decl->initial_value,
                                                  global_uses);
          }
        /* Continua para processar next. */
        collect_global_vars_used_in_function (func_body->next, global_uses);
        break;
      }
    case NODE_ASSIGNMENT:
      {
        TinyOptAssignmentNode_t *assign = (TinyOptAssignmentNode_t *)func_body;
        /* A variável atribuída pode ser global ou local, mas vamos coletá-la
         * de qualquer forma. Se for local, não causará problema porque
         * verificaremos se a declaração global existe. */
        if (assign->variable)
          {
            uint64_t h = stab_hash_string (assign->variable);
            varset_add (global_uses, h);
          }
        if (assign->value)
          {
            collect_global_vars_used_in_function (assign->value, global_uses);
          }
        collect_global_vars_used_in_function (func_body->next, global_uses);
        break;
      }
    case NODE_RETURN:
      {
        TinyOptReturnNode_t *ret = (TinyOptReturnNode_t *)func_body;
        if (ret->value)
          {
            collect_global_vars_used_in_function (ret->value, global_uses);
          }
        collect_global_vars_used_in_function (func_body->next, global_uses);
        break;
      }
    case NODE_IF_STATEMENT:
      {
        TinyOptIfNode_t *if_node = (TinyOptIfNode_t *)func_body;
        if (if_node->condition)
          {
            collect_global_vars_used_in_function (if_node->condition,
                                                  global_uses);
          }
        if (if_node->then_statement)
          {
            collect_global_vars_used_in_function (if_node->then_statement,
                                                  global_uses);
          }
        if (if_node->else_statement)
          {
            collect_global_vars_used_in_function (if_node->else_statement,
                                                  global_uses);
          }
        collect_global_vars_used_in_function (func_body->next, global_uses);
        break;
      }
    case NODE_WHILE_STATEMENT:
      {
        TinyOptWhileNode_t *while_node = (TinyOptWhileNode_t *)func_body;
        if (while_node->condition)
          {
            collect_global_vars_used_in_function (while_node->condition,
                                                  global_uses);
          }
        if (while_node->body)
          {
            collect_global_vars_used_in_function (while_node->body,
                                                  global_uses);
          }
        collect_global_vars_used_in_function (func_body->next, global_uses);
        break;
      }
    case NODE_FOR_STATEMENT:
      {
        TinyOptForNode_t *for_node = (TinyOptForNode_t *)func_body;
        if (for_node->init)
          {
            collect_global_vars_used_in_function (for_node->init, global_uses);
          }
        if (for_node->condition)
          {
            collect_global_vars_used_in_function (for_node->condition,
                                                  global_uses);
          }
        if (for_node->increment)
          {
            collect_global_vars_used_in_function (for_node->increment,
                                                  global_uses);
          }
        if (for_node->body)
          {
            collect_global_vars_used_in_function (for_node->body, global_uses);
          }
        collect_global_vars_used_in_function (func_body->next, global_uses);
        break;
      }
    case NODE_COMPOUND_STATEMENT:
      {
        TinyOptCompoundNode_t *compound = (TinyOptCompoundNode_t *)func_body;
        if (compound->statements)
          {
            collect_global_vars_used_in_function (compound->statements,
                                                  global_uses);
          }
        collect_global_vars_used_in_function (func_body->next, global_uses);
        break;
      }
    case NODE_FUNCTION_CALL:
      {
        TinyOptFunctionCallNode_t *call
            = (TinyOptFunctionCallNode_t *)func_body;
        if (call->arguments)
          {
            collect_global_vars_used_in_function (call->arguments,
                                                  global_uses);
          }
        collect_global_vars_used_in_function (func_body->next, global_uses);
        break;
      }
    case NODE_BINARY_OP:
      {
        TinyOptBinaryOpNode_t *bin = (TinyOptBinaryOpNode_t *)func_body;
        if (bin->left)
          {
            collect_global_vars_used_in_function (bin->left, global_uses);
          }
        if (bin->right)
          {
            collect_global_vars_used_in_function (bin->right, global_uses);
          }
        collect_global_vars_used_in_function (func_body->next, global_uses);
        break;
      }
    case NODE_UNARY_OP:
      {
        TinyOptUnaryOpNode_t *unary = (TinyOptUnaryOpNode_t *)func_body;
        if (unary->operand)
          {
            collect_global_vars_used_in_function (unary->operand, global_uses);
          }
        collect_global_vars_used_in_function (func_body->next, global_uses);
        break;
      }
    case NODE_CONDITION:
      {
        TinyOptConditionNode_t *cond = (TinyOptConditionNode_t *)func_body;
        if (cond->left)
          {
            collect_global_vars_used_in_function (cond->left, global_uses);
          }
        if (cond->right)
          {
            collect_global_vars_used_in_function (cond->right, global_uses);
          }
        collect_global_vars_used_in_function (func_body->next, global_uses);
        break;
      }
    case NODE_NUMBER:
    case NODE_CHAR_LITERAL:
    case NODE_STRING_LITERAL:
      /* Não contêm variáveis. */
      collect_global_vars_used_in_function (func_body->next, global_uses);
      break;
    default:
      /* Para outros tipos, apenas processa next. */
      collect_global_vars_used_in_function (func_body->next, global_uses);
      break;
    }
}
