/*⠀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⣿⢫⣶⢾⣰⣿⣑⣶⣕⡫⢙⣭⣖⣷⣶⣹⣿⣻⣟⠉⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⣿⣮⡟⣼⣶⣶⠶⠶⠶⢶⣶⢶⠶⠶⠶⢶⣶⣶⡶⢰⢿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⣿⡼⠱⣫⣶⣾⠟⠿⣿⠨⣆⣿⢰⣿⠿⣿⢶⣬⠃⣷⣾⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⣿⢿⣾⢿⣷⣌⣀⣈⣿⠘⣧⢸⢸⡿⡟⢁⣋⡩⣷⣬⣾⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⣿⠹⣑⡲⣶⣦⡻⠿⣿⢠⣍⢴⢸⣿⣰⣿⡿⢃⣜⢗⣸⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⣿⢸⢿⡿⠋⠙⣿⠹⣿⢸⠏⠾⢸⣯⢣⣾⣟⣻⣭⡛⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⣤⣤⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⣿⣞⢾⣧⣻⣾⣋⣾⣾⠀⠸⢓⢸⡟⣆⢿⢼⣗⠉⡽⣸⡇⠀⠀⣠⡦⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠂⠁⠀⠉⠙⢿⣷⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡀⠀⠀
 *⠀⣿⢛⣥⣬⣛⡿⣦⢫⣿⢸⣇⣿⢸⡿⣳⣥⣜⣿⢿⡾⢿⡇⠀⠀⢈⡀⠀⠀⢀⡀⠀⢀⣀⠀⠀⠀⣀⡀⠀⠀⠀⢀⡀⠀⠀⣴⠃⠀⠀⠀⠀⠀⠀⢻⣿⠀⠀⣀⡀⠀⢀⣀⠀⠀⢀⣾⣇⣀⡀
 *⠀⣿⣿⢋⣽⣶⣯⡈⢼⣿⠸⣦⢸⢸⡟⠿⢍⣿⣝⠸⣸⢿⡇⠀⠐⢿⡇⠀⠐⢿⡧⠐⠙⢻⣷⠀⠈⢻⣿⠀⠀⠀⢻⣷⠀⢸⣿⠀⠀⠀⠀⠀⠀⠀⠈⣿⠂⠘⣿⡧⠊⠙⢿⣷⠀⠉⣿⡏⠉⠀
 *⠀⣿⡗⣼⣟⣉⢻⡹⢸⣿⢸⡌⣸⠘⡿⠿⣿⣟⣻⡇⣱⣿⡇⠀⠀⢸⡇⠀⠀⢸⡇⠀⠀⢸⣿⠀⠀⢸⣿⠀⠀⠀⢸⣿⠀⢸⣿⡀⠀⠀⠀⠀⠀⠀⢀⡿⠀⠀⣿⡇⠀⠀⠈⣿⠀⠀⣿⡇⠀⠀
 *⠀⣿⣷⢩⣿⣵⡿⣣⡾⣣⣟⣁⣙⣧⡻⢇⡽⢟⣉⠪⢭⣿⡇⠀⠀⢸⡇⠀⠀⢸⡇⠀⠀⢸⣿⠀⠀⢸⣿⡀⠀⠀⣸⡇⠀⠈⢿⣷⣄⠀⠀⠀⠀⢀⡼⠁⠀⠀⣿⡇⠀⠀⢀⠟⠀⠀⣿⡇⠀⠀
 *⠀⠿⠶⠾⠿⠶⠿⠿⠶⠶⠶⠶⠶⠶⠶⠾⠿⠿⠿⠿⠾⠿⠇⠀⠀⠸⠿⠂⠀⠸⠿⠂⠀⠘⠿⠓⠀⠈⠻⡿⠒⠁⢸⣷⠀⠀⠀⠙⠻⠿⠶⠶⠖⠉⠀⠀⠀⠀⣿⡿⠿⠖⠀⠀⠀⠀⠻⠿⠖⠀
 *⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⡎⠀⠀⠀⢸⠏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⠻⠿⠶⠂⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠛⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *  TinyOpt
 *  Copyright (c) 2025 leozamboni
 *
 *  this program is free software: you can redistribute it and/or modify
 *  it under the terms of the gnu general public license as published by
 *  the free software foundation, either version 3 of the license, or
 *  (at your option) any later version.
 *
 *  this program is distributed in the hope that it will be useful,
 *  but without any warranty; without even the implied warranty of
 *  merchantability or fitness for a particular purpose.  see the
 *  gnu general public license for more details.
 *
 *  you should have received a copy of the gnu general public license
 *  along with this program.  if not, see <http://www.gnu.org/licenses/>.
 */
#include "tinyopt_liveness.h"
#include "tinyopt_cfg.h"
#include "tinyopt_stab.h"
#include <stdlib.h>
#include <string.h>

typedef struct
{
  uint64_t *data;
  size_t size;
  size_t capacity;
} VarSet;

static void varset_init (VarSet *s);
static void varset_free (VarSet *s);
static int varset_contains (VarSet *s, uint64_t v);
static int varset_add (VarSet *s, uint64_t v);
static int varset_union_into (VarSet *dst, VarSet *src);
static void varset_minus (VarSet *dst, VarSet *remove);

static void collect_uses_expr (TinyOptASTNode_t *node, VarSet *use);
static void compute_use_def_for_node (TinyOptCFGNode_t *n, VarSet *use,
                                      VarSet *def);

void
tinyopt_liveness (TinyOptASTNode_t *ast)
{
  if (!ast)
    return;

  TinyOptCFG_t *cfg = tinyopt_cfg_build (ast);
  if (!cfg || !cfg->nodes)
    {
      if (cfg)
        tinyopt_cfg_free (cfg);
      return;
    }

  /* Conta nós e determina o maior id para dimensionar vetores por id-1. */
  size_t count = 0;
  int max_id = 0;
  for (TinyOptCFGNode_t *n = cfg->nodes; n; n = n->next_in_cfg)
    {
      count++;
      if (n->id > max_id)
        max_id = n->id;
    }

  if (max_id <= 0)
    {
      tinyopt_cfg_free (cfg);
      return;
    }

  size_t n_nodes = (size_t)max_id;

  VarSet *use = (VarSet *)calloc (n_nodes, sizeof (VarSet));
  VarSet *def = (VarSet *)calloc (n_nodes, sizeof (VarSet));
  VarSet *in = (VarSet *)calloc (n_nodes, sizeof (VarSet));
  VarSet *out = (VarSet *)calloc (n_nodes, sizeof (VarSet));

  if (!use || !def || !in || !out)
    {
      free (use);
      free (def);
      free (in);
      free (out);
      tinyopt_cfg_free (cfg);
      return;
    }

  for (size_t i = 0; i < n_nodes; i++)
    {
      varset_init (&use[i]);
      varset_init (&def[i]);
      varset_init (&in[i]);
      varset_init (&out[i]);
    }

  /* Computa USE/DEF de cada nó. */
  for (TinyOptCFGNode_t *n = cfg->nodes; n; n = n->next_in_cfg)
    {
      if (n->id <= 0)
        continue;
      size_t idx = (size_t)(n->id - 1);
      compute_use_def_for_node (n, &use[idx], &def[idx]);
    }

  /* Iteração de ponto fixo: IN/OUT. */
  int changed;
  int iter = 0;
  const int max_iter = 1000;
  do
    {
      changed = 0;
      iter++;

      for (TinyOptCFGNode_t *n = cfg->nodes; n; n = n->next_in_cfg)
        {
          if (n->id <= 0)
            continue;
          size_t idx = (size_t)(n->id - 1);

          /* OUT[n] = união dos IN dos sucessores */
          VarSet new_out;
          varset_init (&new_out);

          // printf ("%d : %d\n", idx, n->ast->type);

          if (n->succ_true && n->succ_true->id > 0)
            {
              // printf("n->succ_true->id %d\n", n->succ_true->id);
              size_t tidx = (size_t)(n->succ_true->id - 1);
              varset_union_into (&new_out, &in[tidx]);
            }
          if (n->succ_false && n->succ_false->id > 0)
            {
              size_t fidx = (size_t)(n->succ_false->id - 1);
              varset_union_into (&new_out, &in[fidx]);
            }

          /* Verifica se OUT mudou (tamanho ou conteúdo). */
          int out_changed = 0;
          if (new_out.size != out[idx].size)
            {
              out_changed = 1;
            }
          else
            {
              for (size_t k = 0; k < new_out.size; k++)
                {
                  if (!varset_contains (&out[idx], new_out.data[k]))
                    {
                      out_changed = 1;
                      break;
                    }
                }
            }

          if (out_changed)
            {
              varset_free (&out[idx]);
              out[idx] = new_out;
            }
          else
            {
              varset_free (&new_out);
            }

          // if (n->ast)
          //   {
          //     TinyOptASTNode_t *node = n->ast;
          //     if (node->type == NODE_ASSIGNMENT)
          //       {
          //         TinyOptDeclarationNode_t *d
          //             = (TinyOptDeclarationNode_t *)node;
          //         uint64_t h = stab_hash_string (d->name);
          //         if (!varset_contains (&out[idx], h))
          //           {
          //             varset_minus (&use[idx], &def[idx]);
          //           }
          //       }
          //   }

          /* IN[n] = USE[n] ∪ (OUT[n] – DEF[n]) */
          VarSet new_in;
          varset_init (&new_in);

          varset_union_into (&new_in, &out[idx]);
          varset_minus (&new_in, &def[idx]);
          // varset_minus (&use[idx], &def[idx]);
          varset_union_into (&new_in, &use[idx]);

          // printf ("USE[%zu] = { ", idx);

          // for (size_t i = 0; i < use[idx].size; i++)
          //   {
          //     printf ("%d ", use[idx].data[i]);
          //   }

          // printf ("}\n");
          // printf ("DEF[%zu] = { ", idx);

          // for (size_t i = 0; i < def[idx].size; i++)
          //   {
          //     printf ("%d ", def[idx].data[i]);
          //   }

          // printf ("}\n");

          int in_changed = 0;
          if (new_in.size != in[idx].size)
            {
              in_changed = 1;
            }
          else
            {
              for (size_t k = 0; k < new_in.size; k++)
                {
                  if (!varset_contains (&in[idx], new_in.data[k]))
                    {
                      in_changed = 1;
                      break;
                    }
                }
            }

          if (in_changed)
            {
              varset_free (&in[idx]);
              in[idx] = new_in;
            }
          else
            {
              varset_free (&new_in);
            }

          // printf ("out_changed %d | in_changed %d\n", out_changed,
          // in_changed);
          if (out_changed || in_changed)
            changed = 1;
        }
    }
  while (changed && iter < max_iter);

  /* Marca declarações/atribuições cujo valor nunca está vivo após o nó. */
  /* Primeiro, coletamos todas as variáveis que são de fato usadas em
   * expressões (USE sets) para poder remover declarações completamente
   * não utilizadas. */
  VarSet used_vars;
  varset_init (&used_vars);
  for (TinyOptCFGNode_t *n = cfg->nodes; n; n = n->next_in_cfg)
    {
      if (!n->ast || n->id <= 0)
        continue;
      // printf("%d: %d\n", n->id, n->ast->type);
      size_t idx = (size_t)(n->id - 1);
      varset_union_into (&used_vars, &use[idx]);
    }

  for (TinyOptCFGNode_t *n = cfg->nodes; n; n = n->next_in_cfg)
    {
      if (!n->ast || n->id <= 0)
        continue;

      TinyOptASTNode_t *node = n->ast;

      /* Declarações completamente não utilizadas (variável nunca aparece em
       * nenhum USE) podem ser removidas com segurança. */
      if (node->type == NODE_DECLARATION)
        {
          TinyOptDeclarationNode_t *d = (TinyOptDeclarationNode_t *)node;
          if (d->name)
            {
              uint64_t h = stab_hash_string (d->name);
              if (!varset_contains (&used_vars, h))
                {
                  node->is_dead_code = 1;
                  continue;
                }
            }
        }

      /* Por segurança, só removemos atribuições mortas.
       * Declarações são mantidas para preservar a correção do código gerado,
       * mesmo que a definição inicial nunca seja utilizada.
       */
      if (node->type != NODE_ASSIGNMENT)
        continue;

      uint64_t var_hash = 0;
      TinyOptAssignmentNode_t *a = (TinyOptAssignmentNode_t *)node;
      if (a->variable)
        var_hash = stab_hash_string (a->variable);

      if (!var_hash)
        continue;

      size_t idx = (size_t)(n->id - 1);
      if (!varset_contains (&out[idx], var_hash))
        {
          node->is_dead_code = 1;
        }
    }

  for (size_t i = 0; i < n_nodes; i++)
    {
      varset_free (&use[i]);
      varset_free (&def[i]);
      varset_free (&in[i]);
      varset_free (&out[i]);
    }

  free (use);
  free (def);
  free (in);
  free (out);

  tinyopt_cfg_free (cfg);
}

static void
varset_init (VarSet *s)
{
  s->data = NULL;
  s->size = 0;
  s->capacity = 0;
}

static void
varset_free (VarSet *s)
{
  free (s->data);
  s->data = NULL;
  s->size = 0;
  s->capacity = 0;
}

static int
varset_contains (VarSet *s, uint64_t v)
{
  for (size_t i = 0; i < s->size; i++)
    {
      if (s->data[i] == v)
        return 1;
    }
  return 0;
}

static int
varset_add (VarSet *s, uint64_t v)
{
  if (varset_contains (s, v))
    return 0;

  if (s->size == s->capacity)
    {
      size_t new_cap = s->capacity ? s->capacity * 2 : 4;
      uint64_t *new_data
          = (uint64_t *)realloc (s->data, new_cap * sizeof (uint64_t));
      if (!new_data)
        return -1;
      s->data = new_data;
      s->capacity = new_cap;
    }
  s->data[s->size++] = v;
  return 1;
}

static int
varset_union_into (VarSet *dst, VarSet *src)
{
  int changed = 0;
  for (size_t i = 0; i < src->size; i++)
    {
      if (varset_add (dst, src->data[i]) == 1)
        changed = 1;
    }
  return changed;
}

static void
varset_minus (VarSet *dst, VarSet *remove)
{
  size_t w = 0;
  for (size_t i = 0; i < dst->size; i++)
    {
      uint64_t v = dst->data[i];
      if (!varset_contains (remove, v))
        {
          dst->data[w++] = v;
        }
    }
  dst->size = w;
}

static void
collect_uses_expr (TinyOptASTNode_t *node, VarSet *use)
{
  if (!node)
    return;

  switch (node->type)
    {
    case NODE_IDENTIFIER:
      {
        TinyOptIdentifierNode_t *id = (TinyOptIdentifierNode_t *)node;
        if (id->name)
          {
            uint64_t h = stab_hash_string (id->name);
            varset_add (use, h);
          }
        break;
      }
    case NODE_NUMBER:
    case NODE_CHAR_LITERAL:
    case NODE_STRING_LITERAL:
      /* não usam variáveis */
      break;
    case NODE_BINARY_OP:
      {
        TinyOptBinaryOpNode_t *b = (TinyOptBinaryOpNode_t *)node;
        collect_uses_expr (b->left, use);
        collect_uses_expr (b->right, use);
        break;
      }
    case NODE_CONDITION:
      {
        TinyOptConditionNode_t *c = (TinyOptConditionNode_t *)node;
        collect_uses_expr (c->left, use);
        collect_uses_expr (c->right, use);
        break;
      }
    case NODE_UNARY_OP:
      {
        TinyOptUnaryOpNode_t *u = (TinyOptUnaryOpNode_t *)node;
        collect_uses_expr (u->operand, use);
        break;
      }
    case NODE_FUNCTION_CALL:
      {
        TinyOptFunctionCallNode_t *call = (TinyOptFunctionCallNode_t *)node;
        TinyOptASTNode_t *args = call->arguments;
        while (args)
          {
            collect_uses_expr (args, use);
            args = args->next;
          }
        break;
      }
    default:
      /* fallback genérico: percorre next como lista de expressões */
      collect_uses_expr (node->next, use);
      break;
    }
}

static void
compute_use_def_for_node (TinyOptCFGNode_t *n, VarSet *use, VarSet *def)
{
  if (!n || !n->ast)
    return;

  TinyOptASTNode_t *node = n->ast;

  switch (node->type)
    {
    case NODE_DECLARATION:
      {
        TinyOptDeclarationNode_t *d = (TinyOptDeclarationNode_t *)node;
        if (d->name)
          {
            uint64_t h = stab_hash_string (d->name);
            varset_add (def, h);
          }
        if (d->initial_value)
          collect_uses_expr (d->initial_value, use);
        break;
      }
    case NODE_ASSIGNMENT:
      {
        TinyOptAssignmentNode_t *a = (TinyOptAssignmentNode_t *)node;
        if (a->variable)
          {
            uint64_t h = stab_hash_string (a->variable);
            varset_add (def, h);
            if (a->op != OP_ASSIGN)
              {
                varset_add (use, h);
              }
          }

        if (a->value)
          collect_uses_expr (a->value, use);
        break;
      }
    case NODE_RETURN:
      {
        TinyOptReturnNode_t *r = (TinyOptReturnNode_t *)node;
        if (r->value)
          collect_uses_expr (r->value, use);
        break;
      }
    case NODE_IF_STATEMENT:
      {
        TinyOptIfNode_t *i = (TinyOptIfNode_t *)node;
        if (i->condition)
          collect_uses_expr (i->condition, use);
        break;
      }
    case NODE_WHILE_STATEMENT:
      {
        TinyOptWhileNode_t *w = (TinyOptWhileNode_t *)node;
        if (w->condition)
          collect_uses_expr (w->condition, use);
        break;
      }
    case NODE_FOR_STATEMENT:
      {
        TinyOptForNode_t *f = (TinyOptForNode_t *)node;
        if (f->condition)
          collect_uses_expr (f->condition, use);
        break;
      }
    case NODE_FUNCTION_CALL:
      {
        TinyOptFunctionCallNode_t *call = (TinyOptFunctionCallNode_t *)node;
        TinyOptASTNode_t *args = call->arguments;
        while (args)
          {
            collect_uses_expr (args, use);
            args = args->next;
          }
        break;
      }
    default:
      /* outros tipos: podem conter expressões; tenta tratá-los como expressão
       */
      collect_uses_expr (node, use);
      break;
    }
}
