/*⠀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⣿⢫⣶⢾⣰⣿⣑⣶⣕⡫⢙⣭⣖⣷⣶⣹⣿⣻⣟⠉⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⣿⣮⡟⣼⣶⣶⠶⠶⠶⢶⣶⢶⠶⠶⠶⢶⣶⣶⡶⢰⢿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⣿⡼⠱⣫⣶⣾⠟⠿⣿⠨⣆⣿⢰⣿⠿⣿⢶⣬⠃⣷⣾⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⣿⢿⣾⢿⣷⣌⣀⣈⣿⠘⣧⢸⢸⡿⡟⢁⣋⡩⣷⣬⣾⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⣿⠹⣑⡲⣶⣦⡻⠿⣿⢠⣍⢴⢸⣿⣰⣿⡿⢃⣜⢗⣸⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⣿⢸⢿⡿⠋⠙⣿⠹⣿⢸⠏⠾⢸⣯⢣⣾⣟⣻⣭⡛⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⣤⣤⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⣿⣞⢾⣧⣻⣾⣋⣾⣾⠀⠸⢓⢸⡟⣆⢿⢼⣗⠉⡽⣸⡇⠀⠀⣠⡦⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠂⠁⠀⠉⠙⢿⣷⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡀⠀⠀
 *⠀⣿⢛⣥⣬⣛⡿⣦⢫⣿⢸⣇⣿⢸⡿⣳⣥⣜⣿⢿⡾⢿⡇⠀⠀⢈⡀⠀⠀⢀⡀⠀⢀⣀⠀⠀⠀⣀⡀⠀⠀⠀⢀⡀⠀⠀⣴⠃⠀⠀⠀⠀⠀⠀⢻⣿⠀⠀⣀⡀⠀⢀⣀⠀⠀⢀⣾⣇⣀⡀
 *⠀⣿⣿⢋⣽⣶⣯⡈⢼⣿⠸⣦⢸⢸⡟⠿⢍⣿⣝⠸⣸⢿⡇⠀⠐⢿⡇⠀⠐⢿⡧⠐⠙⢻⣷⠀⠈⢻⣿⠀⠀⠀⢻⣷⠀⢸⣿⠀⠀⠀⠀⠀⠀⠀⠈⣿⠂⠘⣿⡧⠊⠙⢿⣷⠀⠉⣿⡏⠉⠀
 *⠀⣿⡗⣼⣟⣉⢻⡹⢸⣿⢸⡌⣸⠘⡿⠿⣿⣟⣻⡇⣱⣿⡇⠀⠀⢸⡇⠀⠀⢸⡇⠀⠀⢸⣿⠀⠀⢸⣿⠀⠀⠀⢸⣿⠀⢸⣿⡀⠀⠀⠀⠀⠀⠀⢀⡿⠀⠀⣿⡇⠀⠀⠈⣿⠀⠀⣿⡇⠀⠀
 *⠀⣿⣷⢩⣿⣵⡿⣣⡾⣣⣟⣁⣙⣧⡻⢇⡽⢟⣉⠪⢭⣿⡇⠀⠀⢸⡇⠀⠀⢸⡇⠀⠀⢸⣿⠀⠀⢸⣿⡀⠀⠀⣸⡇⠀⠈⢿⣷⣄⠀⠀⠀⠀⢀⡼⠁⠀⠀⣿⡇⠀⠀⢀⠟⠀⠀⣿⡇⠀⠀
 *⠀⠿⠶⠾⠿⠶⠿⠿⠶⠶⠶⠶⠶⠶⠶⠾⠿⠿⠿⠿⠾⠿⠇⠀⠀⠸⠿⠂⠀⠸⠿⠂⠀⠘⠿⠓⠀⠈⠻⡿⠒⠁⢸⣷⠀⠀⠀⠙⠻⠿⠶⠶⠖⠉⠀⠀⠀⠀⣿⡿⠿⠖⠀⠀⠀⠀⠻⠿⠖⠀
 *⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⡎⠀⠀⠀⢸⠏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⠻⠿⠶⠂⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠛⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *  TinyOpt
 *  Copyright (c) 2025 leozamboni 
 *
 *  this program is free software: you can redistribute it and/or modify
 *  it under the terms of the gnu general public license as published by
 *  the free software foundation, either version 3 of the license, or
 *  (at your option) any later version.
 *
 *  this program is distributed in the hope that it will be useful,
 *  but without any warranty; without even the implied warranty of
 *  merchantability or fitness for a particular purpose.  see the
 *  gnu general public license for more details.
 *
 *  you should have received a copy of the gnu general public license
 *  along with this program.  if not, see <http://www.gnu.org/licenses/>.
 */
#include "tinyopt_cfg.h"
#include <stdlib.h>

typedef struct CFGBuildResult
{
  TinyOptCFGNode_t *entry;
  TinyOptCFGNode_t *exit;
} CFGBuildResult;

static int cfg_node_counter = 0;
static TinyOptCFG_t *current_cfg = NULL;

static TinyOptCFGNode_t *new_cfg_node (TinyOptASTNode_t *ast);
static CFGBuildResult build_cfg_stmt (TinyOptASTNode_t *stmt);
static CFGBuildResult build_cfg_list (TinyOptASTNode_t *list);
static CFGBuildResult build_linear_stmt (TinyOptASTNode_t *stmt);

static TinyOptCFGNode_t *
new_cfg_node (TinyOptASTNode_t *ast)
{
  TinyOptCFGNode_t *n = (TinyOptCFGNode_t *)malloc (sizeof (TinyOptCFGNode_t));
  if (!n)
    return NULL;

  n->id = ++cfg_node_counter;
  n->ast = ast;
  n->succ_true = NULL;
  n->succ_false = NULL;

  /* insere na lista encadeada do CFG atual */
  if (current_cfg)
    {
      n->next_in_cfg = current_cfg->nodes;
      current_cfg->nodes = n;
    }
  else
    {
      n->next_in_cfg = NULL;
    }

  return n;
}

static CFGBuildResult
build_linear_stmt (TinyOptASTNode_t *stmt)
{
  CFGBuildResult r;
  r.entry = r.exit = new_cfg_node (stmt);
  return r;
}

static CFGBuildResult
build_cfg_stmt (TinyOptASTNode_t *stmt)
{
  CFGBuildResult r = { 0 };

  if (!stmt)
    return r;

  switch (stmt->type)
    {
    case NODE_IF_STATEMENT:
      {
        TinyOptIfNode_t *i = (TinyOptIfNode_t *)stmt;

        if (!i->condition && !i->then_statement && i->else_statement)
          {
            return build_cfg_stmt (i->else_statement);
          }
        if (!i->condition && i->then_statement && !i->else_statement)
          {
            return build_cfg_stmt (i->then_statement);
          }
        if (!i->then_statement && !i->else_statement)
          {
            CFGBuildResult empty = { 0 };
            return empty;
          }

        TinyOptCFGNode_t *cond = new_cfg_node (i->condition);

        CFGBuildResult then_r = { 0 };
        CFGBuildResult else_r = { 0 };

        if (i->then_statement)
          then_r = build_cfg_stmt (i->then_statement);
        if (i->else_statement)
          else_r = build_cfg_stmt (i->else_statement);

        TinyOptCFGNode_t *join = new_cfg_node (NULL);

        /* Ligações de saída da condição */
        cond->succ_true = then_r.entry ? then_r.entry : join;
        cond->succ_false = else_r.entry ? else_r.entry : join;

        /* Ligações de saída dos ramos */
        if (then_r.exit)
          then_r.exit->succ_true = join;
        if (else_r.exit)
          else_r.exit->succ_true = join;

        r.entry = cond;
        r.exit = join;
        return r;
      }
    case NODE_WHILE_STATEMENT:
      {
        TinyOptWhileNode_t *w = (TinyOptWhileNode_t *)stmt;

        TinyOptCFGNode_t *cond = new_cfg_node (w->condition);
        CFGBuildResult body_r = { 0 };
        if (w->body)
          body_r = build_cfg_stmt (w->body);

        TinyOptCFGNode_t *after = new_cfg_node (NULL);

        /* cond verdadeiro entra no corpo (ou volta para cond se não houver) */
        cond->succ_true = body_r.entry ? body_r.entry : cond;
        /* cond falso sai do laço */
        cond->succ_false = after;

        if (body_r.exit)
          body_r.exit->succ_true = cond;

        r.entry = cond;
        r.exit = after;
        return r;
      }
    case NODE_FOR_STATEMENT:
      {
        TinyOptForNode_t *f = (TinyOptForNode_t *)stmt;

        CFGBuildResult init_r = { 0 };
        if (f->init)
          init_r = build_cfg_stmt (f->init);

        TinyOptCFGNode_t *cond = new_cfg_node (f->condition);

        CFGBuildResult body_r = { 0 };
        if (f->body)
          body_r = build_cfg_stmt (f->body);

        CFGBuildResult inc_r = { 0 };
        if (f->increment)
          inc_r = build_cfg_stmt (f->increment);

        TinyOptCFGNode_t *after = new_cfg_node (NULL);

        /* encadeamento init -> cond */
        if (init_r.exit)
          init_r.exit->succ_true = cond;
        else if (init_r.entry)
          init_r.entry->succ_true = cond;

        /* condição verdadeira entra no corpo (ou volta para cond) */
        cond->succ_true = body_r.entry ? body_r.entry : cond;
        /* condição falsa sai do laço */
        cond->succ_false = after;

        if (body_r.exit)
          {
            if (inc_r.entry)
              {
                body_r.exit->succ_true = inc_r.entry;
                if (inc_r.exit)
                  inc_r.exit->succ_true = cond;
                else
                  inc_r.entry->succ_true = cond;
              }
            else
              {
                body_r.exit->succ_true = cond;
              }
          }

        r.entry = init_r.entry ? init_r.entry : cond;
        r.exit = after;
        return r;
      }
    case NODE_COMPOUND_STATEMENT:
      {
        TinyOptCompoundNode_t *c = (TinyOptCompoundNode_t *)stmt;
        return build_cfg_list (c->statements);
      }
    case NODE_FUNCTION_DEF:
      {
        TinyOptFunctionDefNode_t *f = (TinyOptFunctionDefNode_t *)stmt;

        TinyOptCFGNode_t *entry = new_cfg_node ((TinyOptASTNode_t *)f);
        CFGBuildResult body_r = { 0 };

        if (f->body)
          body_r = build_cfg_stmt (f->body);

        if (body_r.entry)
          entry->succ_true = body_r.entry;

        r.entry = entry;
        r.exit = body_r.exit ? body_r.exit : entry;
        return r;
      }
    default:
      return build_linear_stmt (stmt);
    }
}

static CFGBuildResult
build_cfg_list (TinyOptASTNode_t *list)
{
  CFGBuildResult r = { 0 };
  TinyOptCFGNode_t *prev_exit = NULL;

  for (TinyOptASTNode_t *cur = list; cur; cur = cur->next)
    {
      CFGBuildResult cr = build_cfg_stmt (cur);

      if (!r.entry)
        r.entry = cr.entry;

      if (prev_exit && cr.entry)
        {
          /* sequência linear: encadeia saída anterior com entrada atual */
          prev_exit->succ_true = cr.entry;
        }

      if (cr.exit)
        prev_exit = cr.exit;
    }

  r.exit = prev_exit;
  return r;
}

TinyOptCFG_t *
tinyopt_cfg_build (TinyOptASTNode_t *ast)
{
  if (!ast)
    return NULL;

  TinyOptCFG_t *cfg = (TinyOptCFG_t *)malloc (sizeof (TinyOptCFG_t));
  if (!cfg)
    return NULL;

  cfg->entry = NULL;
  cfg->exit = NULL;
  cfg->nodes = NULL;

  cfg_node_counter = 0;
  current_cfg = cfg;

  CFGBuildResult r;
  if (ast->type == NODE_PROGRAM)
    {
      TinyOptProgramNode_t *p = (TinyOptProgramNode_t *)ast;
      r = build_cfg_list (p->statements);
    }
  else
    {
      r = build_cfg_stmt (ast);
    }

  cfg->entry = r.entry;
  cfg->exit = r.exit;

  current_cfg = NULL;
  return cfg;
}

void
tinyopt_cfg_free (TinyOptCFG_t *cfg)
{
  if (!cfg)
    return;

  TinyOptCFGNode_t *node = cfg->nodes;
  while (node)
    {
      TinyOptCFGNode_t *next = node->next_in_cfg;
      free (node);
      node = next;
    }

  free (cfg);
}


